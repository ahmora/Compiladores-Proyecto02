In file included from Prueba.cpp:1:0:
MAST.hpp:25:18: error: constructors cannot be declared virtual [-fpermissive]
  virtual Visitor();
                  ^
MAST.hpp:27:23: error: ‘symbolTable’ declared as a ‘virtual’ field
  virtual SymbolTable* symbolTable;
                       ^
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:64:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:64:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:64:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:65:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:65:14: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:77:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:77:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:77:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:78:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:78:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:89:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:89:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:89:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:90:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:90:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:100:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:104:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:104:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:105:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:105:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:117:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:117:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:117:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:118:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:118:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:129:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:129:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:129:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:130:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:130:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:141:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:141:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:141:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:142:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:142:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:152:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:153:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:163:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:164:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:174:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:175:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:185:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:186:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:200:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:209:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:224:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:225:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:244:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:265:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:284:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:301:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:214:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:306:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:254:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:311:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:234:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:316:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:274:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:321:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:190:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:402:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:402:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:407:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:407:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:412:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:412:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:417:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:417:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:430:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:432:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:436:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:438:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:463:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:464:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:509:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:509:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:511:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:512:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:512:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:516:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:516:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:516:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:517:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:521:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:521:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:521:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:522:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:522:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:527:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:527:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:527:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:528:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:528:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:534:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:534:20: note: candidate is:
MAST.hpp:99:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:99:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:539:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:539:20: note: candidate is:
MAST.hpp:115:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:115:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:544:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:544:20: note: candidate is:
MAST.hpp:127:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:127:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:549:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:549:20: note: candidate is:
MAST.hpp:139:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:139:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:556:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:556:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:557:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:557:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:564:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:564:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:565:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:565:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:572:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:572:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:573:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:573:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:578:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:578:21: note: candidate is:
MAST.hpp:203:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:203:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:583:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:583:21: note: candidate is:
MAST.hpp:228:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:228:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:588:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:588:21: note: candidate is:
MAST.hpp:247:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:247:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:593:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:593:21: note: candidate is:
MAST.hpp:268:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:268:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:598:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:598:20: note: candidate is:
MAST.hpp:287:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:287:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:78:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:64:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:64:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:64:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:65:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:65:14: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:77:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:77:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:77:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:78:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:78:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:89:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:89:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:89:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:90:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:90:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:100:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:104:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:104:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:105:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:105:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:117:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:117:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:117:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:118:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:118:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:129:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:129:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:129:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:130:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:130:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:141:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:141:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:141:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:142:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:142:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:152:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:153:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:163:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:164:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:174:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:175:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:185:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:186:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:200:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:209:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:224:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:225:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:244:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:265:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:284:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:301:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:214:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:306:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:254:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:311:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:234:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:316:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:274:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:321:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:190:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:402:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:402:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:407:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:407:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:412:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:412:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:417:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:417:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:430:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:432:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:436:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:438:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:463:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:464:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:509:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:509:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:511:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:512:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:512:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:516:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:516:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:516:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:517:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:521:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:521:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:521:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:522:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:522:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:527:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:527:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:527:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:528:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:528:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:534:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:534:20: note: candidate is:
MAST.hpp:99:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:99:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:539:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:539:20: note: candidate is:
MAST.hpp:115:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:115:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:544:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:544:20: note: candidate is:
MAST.hpp:127:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:127:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:549:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:549:20: note: candidate is:
MAST.hpp:139:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:139:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:556:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:556:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:557:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:557:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:564:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:564:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:565:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:565:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:572:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:572:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:573:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:573:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:578:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:578:21: note: candidate is:
MAST.hpp:203:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:203:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:583:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:583:21: note: candidate is:
MAST.hpp:228:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:228:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:588:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:588:21: note: candidate is:
MAST.hpp:247:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:247:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:593:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:593:21: note: candidate is:
MAST.hpp:268:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:268:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:598:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:598:20: note: candidate is:
MAST.hpp:287:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:287:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:78:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:67:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:67:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:67:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:67:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:68:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:68:14: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:80:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:80:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:80:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:80:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:81:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:81:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:92:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:92:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:92:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:92:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:93:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:93:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:103:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:107:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:107:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:108:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:108:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:120:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:120:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:120:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:120:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:121:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:121:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:132:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:132:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:132:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:132:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:133:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:133:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:144:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:144:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:144:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:144:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:145:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:145:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:155:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:156:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:166:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:167:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:177:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:178:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:188:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:189:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:203:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:212:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:227:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:228:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:247:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:268:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:287:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:304:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:217:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:309:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:257:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:314:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:237:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:319:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:277:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:324:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:193:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:405:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:405:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:410:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:410:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:415:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:415:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:420:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:420:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:433:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:435:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:439:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:441:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:466:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:467:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:512:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:512:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:513:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:513:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:514:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:514:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:515:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:515:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:519:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:519:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:519:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:519:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:519:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:519:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:520:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:524:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:524:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:524:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:524:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:524:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:524:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:525:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:525:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:530:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:530:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:530:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:530:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:530:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:530:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:531:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:531:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:537:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:537:20: note: candidate is:
MAST.hpp:102:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:102:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:542:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:542:20: note: candidate is:
MAST.hpp:118:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:118:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:547:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:547:20: note: candidate is:
MAST.hpp:130:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:130:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:552:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:552:20: note: candidate is:
MAST.hpp:142:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:142:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:559:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:559:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:560:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:560:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:567:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:567:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:568:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:568:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:575:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:575:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:576:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:576:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:581:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:581:21: note: candidate is:
MAST.hpp:206:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:206:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:586:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:586:21: note: candidate is:
MAST.hpp:231:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:231:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:591:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:591:21: note: candidate is:
MAST.hpp:250:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:250:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:596:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:596:21: note: candidate is:
MAST.hpp:271:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:271:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:601:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:601:20: note: candidate is:
MAST.hpp:290:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:290:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:81:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:66:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:66:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:66:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:67:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:67:14: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:79:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:79:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:79:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:80:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:80:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:91:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:91:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:91:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:92:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:92:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:102:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:106:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:106:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:107:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:107:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:119:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:119:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:119:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:120:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:120:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:131:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:131:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:131:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:132:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:132:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:143:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:143:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:143:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:144:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:144:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:154:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:155:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:165:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:166:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:176:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:177:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:187:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:188:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:202:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:211:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:226:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:227:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:246:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:267:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:286:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:303:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:216:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:308:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:256:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:313:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:236:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:318:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:276:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:323:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:192:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:404:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:404:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:409:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:409:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:414:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:414:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:419:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:419:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:432:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:434:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:438:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:440:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:465:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:466:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:511:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:512:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:512:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:513:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:513:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:514:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:514:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:518:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:518:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:518:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:518:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:518:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:519:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:523:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:523:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:523:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:523:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:523:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:524:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:524:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:529:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:529:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:529:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:529:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:529:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:530:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:530:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:536:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:536:20: note: candidate is:
MAST.hpp:101:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:101:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:541:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:541:20: note: candidate is:
MAST.hpp:117:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:117:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:546:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:546:20: note: candidate is:
MAST.hpp:129:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:129:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:551:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:551:20: note: candidate is:
MAST.hpp:141:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:141:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:558:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:558:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:559:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:559:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:566:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:566:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:567:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:567:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:574:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:574:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:575:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:575:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:580:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:580:21: note: candidate is:
MAST.hpp:205:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:205:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:585:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:585:21: note: candidate is:
MAST.hpp:230:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:230:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:590:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:590:21: note: candidate is:
MAST.hpp:249:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:249:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:595:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:595:21: note: candidate is:
MAST.hpp:270:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:270:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:600:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:600:20: note: candidate is:
MAST.hpp:289:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:289:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:80:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:66:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:66:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:66:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:66:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:67:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:67:14: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:79:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:79:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:79:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:79:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:80:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:80:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:91:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:91:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:91:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:91:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:92:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:92:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:102:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:106:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:106:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:107:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:107:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:119:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:119:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:119:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:119:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:120:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:120:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:131:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:131:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:131:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:131:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:132:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:132:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:143:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:143:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:143:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:143:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:144:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:144:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:154:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:155:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:165:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:166:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:176:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:177:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:187:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:188:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:202:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:211:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:226:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:227:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:246:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:267:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:286:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:303:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:216:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:308:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:256:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:313:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:236:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:318:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:276:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:323:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:192:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:404:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:404:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:409:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:409:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:414:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:414:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:419:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:419:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:432:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:434:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:438:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:440:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:465:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:466:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:511:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:512:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:512:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:513:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:513:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:514:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:514:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:518:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:518:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:518:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:518:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:518:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:518:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:519:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:523:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:523:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:523:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:523:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:523:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:523:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:524:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:524:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:529:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:529:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:529:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:529:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:529:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:529:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:530:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:530:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:536:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:536:20: note: candidate is:
MAST.hpp:101:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:101:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:541:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:541:20: note: candidate is:
MAST.hpp:117:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:117:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:546:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:546:20: note: candidate is:
MAST.hpp:129:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:129:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:551:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:551:20: note: candidate is:
MAST.hpp:141:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:141:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:558:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:558:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:559:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:559:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:566:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:566:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:567:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:567:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:574:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:574:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:575:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:575:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:580:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:580:21: note: candidate is:
MAST.hpp:205:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:205:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:585:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:585:21: note: candidate is:
MAST.hpp:230:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:230:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:590:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:590:21: note: candidate is:
MAST.hpp:249:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:249:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:595:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:595:21: note: candidate is:
MAST.hpp:270:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:270:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:600:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:600:20: note: candidate is:
MAST.hpp:289:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:289:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:80:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:64:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:64:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:64:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:65:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:65:14: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:77:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:77:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:77:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:78:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:78:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:89:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:89:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:89:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:90:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:90:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:100:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:104:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:104:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:105:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:105:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:117:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:117:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:117:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:118:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:118:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:129:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:129:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:129:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:130:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:130:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:141:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:141:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:141:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:142:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:142:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:152:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:153:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:163:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:164:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:174:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:175:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:185:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:186:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:200:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:209:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:224:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:225:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:244:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:265:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:284:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:301:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:214:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:306:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:254:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:311:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:234:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:316:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:274:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:321:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:190:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:402:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:402:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:407:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:407:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:412:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:412:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:417:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:417:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:430:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:432:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:436:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:438:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:463:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:464:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:509:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:509:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:511:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:512:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:512:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:516:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:516:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:516:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:517:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:521:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:521:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:521:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:522:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:522:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:527:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:527:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:527:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:528:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:528:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:534:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:534:20: note: candidate is:
MAST.hpp:99:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:99:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:539:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:539:20: note: candidate is:
MAST.hpp:115:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:115:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:544:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:544:20: note: candidate is:
MAST.hpp:127:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:127:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:549:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:549:20: note: candidate is:
MAST.hpp:139:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:139:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:556:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:556:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:557:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:557:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:564:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:564:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:565:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:565:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:572:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:572:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:573:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:573:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:578:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:578:21: note: candidate is:
MAST.hpp:203:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:203:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:583:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:583:21: note: candidate is:
MAST.hpp:228:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:228:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:588:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:588:21: note: candidate is:
MAST.hpp:247:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:247:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:593:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:593:21: note: candidate is:
MAST.hpp:268:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:268:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:598:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:598:20: note: candidate is:
MAST.hpp:287:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:287:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:78:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:64:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:64:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:64:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:65:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:65:14: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:77:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:77:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:77:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:78:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:78:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:89:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:89:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:89:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:90:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:90:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:100:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:104:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:104:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:105:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:105:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:117:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:117:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:117:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:118:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:118:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:129:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:129:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:129:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:130:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:130:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:141:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:141:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:141:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:142:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:142:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*);
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*);
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:152:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:153:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:163:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:164:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:174:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:175:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:185:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:186:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:200:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:209:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:224:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:225:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:244:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:265:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:284:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:301:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:214:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:306:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:254:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:311:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:234:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:316:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:274:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:321:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:190:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:402:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:402:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:407:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:407:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:412:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:412:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:417:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:417:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:430:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:432:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:436:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:438:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:463:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:464:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:509:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:509:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:511:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:512:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:512:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:516:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:516:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:516:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:517:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:521:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:521:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:521:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:522:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:522:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:527:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:527:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:527:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:528:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:528:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:534:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:534:20: note: candidate is:
MAST.hpp:99:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:99:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:539:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:539:20: note: candidate is:
MAST.hpp:115:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:115:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:544:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:544:20: note: candidate is:
MAST.hpp:127:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:127:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:549:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:549:20: note: candidate is:
MAST.hpp:139:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:139:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:556:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:556:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:557:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:557:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:564:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:564:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:565:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:565:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:572:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:572:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:573:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:573:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:578:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:578:21: note: candidate is:
MAST.hpp:203:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:203:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:583:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:583:21: note: candidate is:
MAST.hpp:228:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:228:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:588:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:588:21: note: candidate is:
MAST.hpp:247:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:247:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:593:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:593:21: note: candidate is:
MAST.hpp:268:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:268:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:598:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:598:20: note: candidate is:
MAST.hpp:287:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:287:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:78:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:64:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:64:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:64:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:65:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:65:14: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:77:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:77:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:77:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:78:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:78:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:89:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:89:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:89:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:90:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:90:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:100:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:104:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:104:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:105:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:105:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:117:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:117:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:117:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:118:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:118:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:129:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:129:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:129:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:130:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:130:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:141:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:141:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:141:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:142:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:142:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:152:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:153:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:163:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:164:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:174:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:175:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:185:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:186:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:200:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:209:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:224:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:225:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:244:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:265:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:284:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:301:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:214:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:306:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:254:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:311:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:234:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:316:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:274:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:321:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:190:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:402:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:402:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:407:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:407:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:412:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:412:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:417:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:417:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:430:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:432:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:436:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:438:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:463:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:464:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:509:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:509:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:511:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:512:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:512:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:516:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:516:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:516:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:517:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:521:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:521:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:521:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:522:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:522:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:527:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:527:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:527:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:528:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:528:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:534:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:534:20: note: candidate is:
MAST.hpp:99:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:99:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:539:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:539:20: note: candidate is:
MAST.hpp:115:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:115:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:544:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:544:20: note: candidate is:
MAST.hpp:127:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:127:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:549:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:549:20: note: candidate is:
MAST.hpp:139:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:139:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:556:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:556:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:557:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:557:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:564:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:564:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:565:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:565:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:572:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:572:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:573:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:573:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:578:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:578:21: note: candidate is:
MAST.hpp:203:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:203:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:583:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:583:21: note: candidate is:
MAST.hpp:228:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:228:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:588:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:588:21: note: candidate is:
MAST.hpp:247:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:247:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:593:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:593:21: note: candidate is:
MAST.hpp:268:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:268:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:598:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:598:20: note: candidate is:
MAST.hpp:287:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:287:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:78:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:26:14: error: ISO C++ forbids declaration of ‘VisitorNode’ with no type [-fpermissive]
  VisitorNode();
              ^
MAST.hpp:26:14: error: declaration of ‘int Visitor::VisitorNode()’ [-fpermissive]
MAST.hpp:14:7: error: changes meaning of ‘VisitorNode’ from ‘class VisitorNode’ [-fpermissive]
 class VisitorNode;
       ^
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:65:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:65:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:65:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:66:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:66:14: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:78:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:78:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:78:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:79:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:79:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:90:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:90:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:90:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:91:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:91:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:101:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:105:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:105:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:106:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:106:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:118:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:118:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:118:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:119:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:119:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:130:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:130:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:130:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:131:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:131:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:142:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:142:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:142:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:143:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:143:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:153:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:154:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:164:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:165:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:175:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:176:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:186:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:187:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:201:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:210:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:225:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:226:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:245:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:266:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:285:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:302:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:215:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:307:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:255:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:312:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:235:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:317:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:275:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:322:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:191:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:403:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:403:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:408:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:408:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:413:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:413:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:418:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:418:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:431:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:433:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:437:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:439:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:464:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:465:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:510:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:512:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:512:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:513:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:513:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:517:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:517:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:517:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:517:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:517:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:518:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:522:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:522:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:522:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:522:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:522:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:523:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:523:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:528:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:528:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:528:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:528:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:528:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:529:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:529:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:535:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:535:20: note: candidate is:
MAST.hpp:100:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:100:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:540:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:540:20: note: candidate is:
MAST.hpp:116:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:116:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:545:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:545:20: note: candidate is:
MAST.hpp:128:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:128:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:550:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:550:20: note: candidate is:
MAST.hpp:140:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:140:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:557:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:557:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:558:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:558:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:565:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:565:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:566:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:566:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:573:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:573:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:574:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:574:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:579:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:579:21: note: candidate is:
MAST.hpp:204:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:204:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:584:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:584:21: note: candidate is:
MAST.hpp:229:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:229:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:589:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:589:21: note: candidate is:
MAST.hpp:248:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:248:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:594:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:594:21: note: candidate is:
MAST.hpp:269:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:269:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:599:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:599:20: note: candidate is:
MAST.hpp:288:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:288:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:79:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:64:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:64:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:64:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:65:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:65:14: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:77:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:77:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:77:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:78:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:78:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:89:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:89:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:89:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:90:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:90:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:100:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:104:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:104:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:105:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:105:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:117:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:117:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:117:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:118:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:118:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:129:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:129:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:129:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:130:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:130:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:141:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:141:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:141:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:142:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:142:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:152:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:153:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:163:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:164:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:174:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:175:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:185:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:186:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:200:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:209:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:224:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:225:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:244:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:265:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:284:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:301:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:214:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:306:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:254:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:311:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:234:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:316:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:274:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:321:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:190:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:402:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:402:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:407:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:407:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:412:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:412:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:417:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:417:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:430:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:432:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:436:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:438:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:463:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:464:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:509:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:509:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:511:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:512:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:512:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:516:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:516:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:516:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:517:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:521:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:521:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:521:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:522:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:522:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:527:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:527:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:527:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:528:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:528:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:534:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:534:20: note: candidate is:
MAST.hpp:99:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:99:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:539:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:539:20: note: candidate is:
MAST.hpp:115:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:115:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:544:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:544:20: note: candidate is:
MAST.hpp:127:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:127:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:549:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:549:20: note: candidate is:
MAST.hpp:139:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:139:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:556:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:556:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:557:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:557:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:564:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:564:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:565:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:565:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:572:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:572:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:573:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:573:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:578:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:578:21: note: candidate is:
MAST.hpp:203:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:203:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:583:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:583:21: note: candidate is:
MAST.hpp:228:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:228:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:588:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:588:21: note: candidate is:
MAST.hpp:247:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:247:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:593:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:593:21: note: candidate is:
MAST.hpp:268:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:268:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:598:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:598:20: note: candidate is:
MAST.hpp:287:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:287:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:78:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:64:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:64:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:64:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:64:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:65:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:65:14: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:77:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:77:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:77:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:77:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:78:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:78:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:89:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:89:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:89:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:89:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:90:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:90:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:100:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:104:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:104:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:105:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:105:23: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:117:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:117:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:117:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:117:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:118:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:118:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:129:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:129:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:129:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:129:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:130:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:130:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:141:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:141:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:141:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:141:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:142:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:142:15: note: candidates are:
MAST.hpp:28:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:28:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:29:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:30:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:33:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:33:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:34:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:34:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:40:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:40:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:46:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:46:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:47:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:47:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:152:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:153:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:163:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:164:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:174:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:175:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:185:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:186:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:200:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:205:16: error: ‘class Visitor’ has no member named ‘symbolTable’
   Simbolo *s=v.symbolTable->lookUp(*value.str);
                ^
MAST.hpp:209:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:224:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:225:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:244:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:265:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:284:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:301:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:214:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:306:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:254:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:311:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:234:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:316:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:274:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:321:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:190:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In constructor ‘VisitorNode::VisitorNode()’:
MAST.hpp:379:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable= new SymbolTable;
   ^
MAST.hpp: In constructor ‘VisitorNode::VisitorNode(SymbolTable*)’:
MAST.hpp:383:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable=ts;
   ^
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:402:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:402:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:407:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:407:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:412:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:412:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:417:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:417:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:430:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:432:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:436:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:438:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:463:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:464:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:509:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:509:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:511:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:512:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:512:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:516:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:516:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:516:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:516:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:516:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:517:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:521:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:521:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:521:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:521:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:521:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:522:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:522:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:527:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:527:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:527:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:527:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:527:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:528:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:528:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:534:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:534:20: note: candidate is:
MAST.hpp:99:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:99:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:539:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:539:20: note: candidate is:
MAST.hpp:115:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:115:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:544:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:544:20: note: candidate is:
MAST.hpp:127:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:127:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:549:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:549:20: note: candidate is:
MAST.hpp:139:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:139:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:556:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:556:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:557:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:557:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:564:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:564:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:565:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:565:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:572:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:572:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:573:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:573:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:578:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:578:21: note: candidate is:
MAST.hpp:203:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:203:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:583:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:583:21: note: candidate is:
MAST.hpp:228:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:228:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:588:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:588:21: note: candidate is:
MAST.hpp:247:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:247:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:593:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:593:21: note: candidate is:
MAST.hpp:268:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:268:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:598:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:598:20: note: candidate is:
MAST.hpp:287:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:287:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:78:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:26:14: error: ISO C++ forbids declaration of ‘VisitorNode’ with no type [-fpermissive]
  VisitorNode();
              ^
MAST.hpp:26:14: error: declaration of ‘int Visitor::VisitorNode()’ [-fpermissive]
MAST.hpp:14:7: error: changes meaning of ‘VisitorNode’ from ‘class VisitorNode’ [-fpermissive]
 class VisitorNode;
       ^
MAST.hpp: In member function ‘virtual void ForNode::accept(Visitor&)’:
MAST.hpp:65:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:65:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:65:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:65:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:66:14: error: no matching function for call to ‘Visitor::visit(std::list<Node>::iterator&)’
    v.visit(it);
              ^
MAST.hpp:66:14: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void WhileNode::accept(Visitor&)’:
MAST.hpp:78:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:78:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:78:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:78:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:79:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:79:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void IfNode::accept(Visitor&)’:
MAST.hpp:90:65: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                 ^
MAST.hpp:90:71: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                       ^
MAST.hpp:90:71: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:90:105: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                         ^
MAST.hpp:91:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:91:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void AssignNode::accept(Visitor&)’:
MAST.hpp:101:54: error: cannot dynamic_cast ‘*((AssignNode*)this)->AssignNode::<anonymous>.BinNode::<anonymous>.INode::children’ (of type ‘class NodeList’) to type ‘class IdentNode*’ (target is not pointer or reference to complete type)
   IdentNode* c = dynamic_cast<IdentNode*>(children[0]);
                                                      ^
MAST.hpp:105:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[1]);
                       ^
MAST.hpp:105:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp:106:23: error: no matching function for call to ‘Visitor::visit(NodeList&)’
    v.visit(children[0]);
                       ^
MAST.hpp:106:23: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘NodeList’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void StmtListNode::accept(Visitor&)’:
MAST.hpp:118:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:118:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:118:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:118:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:119:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:119:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void SStmtListNode::accept(Visitor&)’:
MAST.hpp:130:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:130:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:130:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:130:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:131:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:131:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void ExprNode::accept(Visitor&)’:
MAST.hpp:142:66: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                  ^
MAST.hpp:142:72: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                        ^
MAST.hpp:142:72: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:142:106: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
    for (list<Node>::iterator it=children->children.listas->begin(); it != children->children.listas->end(); ++it)
                                                                                                          ^
MAST.hpp:143:15: error: no matching function for call to ‘Visitor::visit(Node&)’
    v.visit(*it);
               ^
MAST.hpp:143:15: note: candidates are:
MAST.hpp:29:15: note: virtual void Visitor::visit(Node*)
  virtual void visit(Node*)=0;
               ^
MAST.hpp:29:15: note:   no known conversion for argument 1 from ‘Node’ to ‘Node*’
MAST.hpp:30:15: note: virtual void Visitor::visit(INode*)
  virtual void visit(INode*)=0;
               ^
MAST.hpp:30:15: note:   no known conversion for argument 1 from ‘Node’ to ‘INode*’
MAST.hpp:31:15: note: virtual void Visitor::visit(BinNode*)
  virtual void visit(BinNode*)=0;
               ^
MAST.hpp:31:15: note:   no known conversion for argument 1 from ‘Node’ to ‘BinNode*’
MAST.hpp:34:15: note: virtual void Visitor::visit(ForNode*)
  virtual void visit(ForNode*)=0;
               ^
MAST.hpp:34:15: note:   no known conversion for argument 1 from ‘Node’ to ‘ForNode*’
MAST.hpp:35:16: note: virtual void Visitor::visit(WhileNode*)
   virtual void visit(WhileNode*)=0;
                ^
MAST.hpp:35:16: note:   no known conversion for argument 1 from ‘Node’ to ‘WhileNode*’
MAST.hpp:36:16: note: virtual void Visitor::visit(IfNode*)
   virtual void visit(IfNode*)=0;
                ^
MAST.hpp:36:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IfNode*’
MAST.hpp:37:16: note: virtual void Visitor::visit(StmtListNode*)
   virtual void visit(StmtListNode*)=0;
                ^
MAST.hpp:37:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StmtListNode*’
MAST.hpp:38:16: note: virtual void Visitor::visit(SStmtListNode*)
   virtual void visit(SStmtListNode*)=0;
                ^
MAST.hpp:38:16: note:   no known conversion for argument 1 from ‘Node’ to ‘SStmtListNode*’
MAST.hpp:39:16: note: virtual void Visitor::visit(ExprNode*)
   virtual void visit(ExprNode*)=0;
                ^
MAST.hpp:39:16: note:   no known conversion for argument 1 from ‘Node’ to ‘ExprNode*’
MAST.hpp:41:16: note: virtual void Visitor::visit(AssignNode*)
   virtual void visit(AssignNode*)=0;
                ^
MAST.hpp:41:16: note:   no known conversion for argument 1 from ‘Node’ to ‘AssignNode*’
MAST.hpp:42:16: note: virtual void Visitor::visit(PlusNode*)
   virtual void visit(PlusNode*)=0;
                ^
MAST.hpp:42:16: note:   no known conversion for argument 1 from ‘Node’ to ‘PlusNode*’
MAST.hpp:43:16: note: virtual void Visitor::visit(MinusNode*)
   virtual void visit(MinusNode*)=0;
                ^
MAST.hpp:43:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MinusNode*’
MAST.hpp:44:16: note: virtual void Visitor::visit(DiviNode*)
   virtual void visit(DiviNode*)=0;
                ^
MAST.hpp:44:16: note:   no known conversion for argument 1 from ‘Node’ to ‘DiviNode*’
MAST.hpp:45:16: note: virtual void Visitor::visit(MultNode*)
   virtual void visit(MultNode*)=0;
                ^
MAST.hpp:45:16: note:   no known conversion for argument 1 from ‘Node’ to ‘MultNode*’
MAST.hpp:47:15: note: virtual void Visitor::visit(IdentNode*)
  virtual void visit(IdentNode*)=0;
               ^
MAST.hpp:47:15: note:   no known conversion for argument 1 from ‘Node’ to ‘IdentNode*’
MAST.hpp:48:16: note: virtual void Visitor::visit(IntNode*)
   virtual void visit(IntNode*)=0;
                ^
MAST.hpp:48:16: note:   no known conversion for argument 1 from ‘Node’ to ‘IntNode*’
MAST.hpp:49:16: note: virtual void Visitor::visit(FloatNode*)
   virtual void visit(FloatNode*)=0;
                ^
MAST.hpp:49:16: note:   no known conversion for argument 1 from ‘Node’ to ‘FloatNode*’
MAST.hpp:50:16: note: virtual void Visitor::visit(StrNode*)
   virtual void visit(StrNode*)=0;
                ^
MAST.hpp:50:16: note:   no known conversion for argument 1 from ‘Node’ to ‘StrNode*’
MAST.hpp:51:16: note: virtual void Visitor::visit(BoolNode*)
   virtual void visit(BoolNode*)=0;
                ^
MAST.hpp:51:16: note:   no known conversion for argument 1 from ‘Node’ to ‘BoolNode*’
MAST.hpp: In member function ‘virtual void PlusNode::accept(Visitor&)’:
MAST.hpp:153:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:154:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MinusNode::accept(Visitor&)’:
MAST.hpp:164:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:165:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void DiviNode::accept(Visitor&)’:
MAST.hpp:175:26: error: lvalue required as unary ‘&’ operand
    v.visit(&getLeftChild());
                          ^
MAST.hpp:176:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual void MultNode::accept(Visitor&)’:
MAST.hpp:186:25: error: lvalue required as unary ‘&’ operand
   v.visit(&getLeftChild());
                         ^
MAST.hpp:187:27: error: lvalue required as unary ‘&’ operand
    v.visit(&getRightChild());
                           ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IdentNode::getValue()’:
MAST.hpp:201:17: error: could not convert ‘((IdentNode*)this)->IdentNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual void IdentNode::accept(Visitor&)’:
MAST.hpp:210:3: error: ‘symbolTable’ was not declared in this scope
   symbolTable.insertName(s);
   ^
MAST.hpp: In member function ‘virtual LeafNode::NValue IntNode::getValue()’:
MAST.hpp:225:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp:226:17: error: could not convert ‘((IntNode*)this)->IntNode::<anonymous>.LeafNode::value.LeafNode::NValue::i’ from ‘int’ to ‘LeafNode::NValue’
    return value.i;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue FloatNode::getValue()’:
MAST.hpp:245:17: error: could not convert ‘((FloatNode*)this)->FloatNode::<anonymous>.LeafNode::value.LeafNode::NValue::f’ from ‘float’ to ‘LeafNode::NValue’
    return value.f;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue StrNode::getValue()’:
MAST.hpp:266:17: error: could not convert ‘((StrNode*)this)->StrNode::<anonymous>.LeafNode::value.LeafNode::NValue::str’ from ‘std::string* {aka std::basic_string<char>*}’ to ‘LeafNode::NValue’
    return value.str;
                 ^
MAST.hpp: In member function ‘virtual LeafNode::NValue BoolNode::getValue()’:
MAST.hpp:285:16: error: could not convert ‘((BoolNode*)this)->BoolNode::<anonymous>.LeafNode::value.LeafNode::NValue::b’ from ‘bool’ to ‘LeafNode::NValue’
   return value.b;
                ^
MAST.hpp: In member function ‘virtual IntNode* MAST::bIntNode(int)’:
MAST.hpp:302:26: error: cannot allocate an object of abstract type ‘IntNode’
    return new IntNode(val);
                          ^
MAST.hpp:215:8: note:   because the following virtual functions are pure within ‘IntNode’:
  class IntNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual StrNode* MAST::bStrNode(std::string)’:
MAST.hpp:307:26: error: cannot allocate an object of abstract type ‘StrNode’
    return new StrNode(val);
                          ^
MAST.hpp:255:8: note:   because the following virtual functions are pure within ‘StrNode’:
  class StrNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual FloatNode* MAST::bFloatNode(float)’:
MAST.hpp:312:28: error: cannot allocate an object of abstract type ‘FloatNode’
    return new FloatNode(val);
                            ^
MAST.hpp:235:8: note:   because the following virtual functions are pure within ‘FloatNode’:
  class FloatNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual BoolNode* MAST::bBoolNode(bool)’:
MAST.hpp:317:27: error: cannot allocate an object of abstract type ‘BoolNode’
    return new BoolNode(val);
                           ^
MAST.hpp:275:8: note:   because the following virtual functions are pure within ‘BoolNode’:
  class BoolNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual IdentNode* MAST::bIdentNode(std::string)’:
MAST.hpp:322:29: error: cannot allocate an object of abstract type ‘IdentNode’
    return new IdentNode(name);
                             ^
MAST.hpp:191:8: note:   because the following virtual functions are pure within ‘IdentNode’:
  class IdentNode : public LeafNode
        ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘void VisitorNode::visit(LeafNode*)’:
MAST.hpp:403:44: error: expected ‘(’ before ‘inode’
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                            ^
MAST.hpp:403:49: error: expected ‘)’ before ‘;’ token
    IntNode* inode = dynamic_cast<IntNode*> inode;
                                                 ^
MAST.hpp:408:44: error: expected ‘(’ before ‘stnode’
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                            ^
MAST.hpp:408:50: error: expected ‘)’ before ‘;’ token
    StrNode* stnode = dynamic_cast<StrNode*>stnode;
                                                  ^
MAST.hpp:413:47: error: expected ‘(’ before ‘flnode’
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                               ^
MAST.hpp:413:53: error: expected ‘)’ before ‘;’ token
    FloatNode* flnode= dynamic_cast<FloatNode*>flnode;
                                                     ^
MAST.hpp:418:47: error: expected ‘(’ before ‘idnode’
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                               ^
MAST.hpp:418:53: error: expected ‘)’ before ‘;’ token
    IdentNode* idnode= dynamic_cast<IdentNode*>idnode;
                                                     ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(INode*)’:
MAST.hpp:431:53: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class StmtNode*’ (target is not pointer or reference to complete type)
    StmtNode* stmtnode = dynamic_cast<StmtNode*>(node);
                                                     ^
MAST.hpp:433:11: error: ‘stmtNode’ was not declared in this scope
     visit(stmtNode);
           ^
MAST.hpp:437:56: error: cannot dynamic_cast ‘node’ (of type ‘class INode*’) to type ‘class SStmtNode*’ (target is not pointer or reference to complete type)
    SStmtNode* sstmtnode = dynamic_cast<SStmtNode*>(node);
                                                        ^
MAST.hpp:439:11: error: ‘sstmtNode’ was not declared in this scope
     visit(sstmtNode);
           ^
MAST.hpp:464:18: error: expected initializer before ‘)’ token
    ForNode* fnode) = dynamic_cast<ForNode*>(node);
                  ^
MAST.hpp:465:6: error: ‘fnode’ was not declared in this scope
   if(fnode!=0){
      ^
MAST.hpp: In member function ‘virtual void VisitorNode::visit(PlusNode*)’:
MAST.hpp:510:35: error: cannot allocate an object of abstract type ‘Node’
    Node left = node->getLeftChild();
                                   ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   because the following virtual functions are pure within ‘Node’:
 class Node{
       ^
AST.hpp:47:15: note: 	virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:48:15: note: 	virtual void Node::addFChild(Node*)
  virtual void addFChild(Node*)=0;
               ^
AST.hpp:49:15: note: 	virtual void Node::addLChild(Node*)
  virtual void addLChild(Node*)=0;
               ^
AST.hpp:50:15: note: 	virtual void Node::setFChild(Node*)
  virtual void setFChild(Node*)=0;
               ^
AST.hpp:51:15: note: 	virtual void Node::setSChild(Node*)
  virtual void setSChild(Node*)=0;
               ^
In file included from Prueba.cpp:1:0:
MAST.hpp:510:9: error: cannot declare variable ‘left’ to be of abstract type ‘Node’
    Node left = node->getLeftChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:37: error: cannot allocate an object of abstract type ‘Node’
    Node right = node->getRightChild();
                                     ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:511:9: error: cannot declare variable ‘right’ to be of abstract type ‘Node’
    Node right = node->getRightChild();
         ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
In file included from Prueba.cpp:1:0:
MAST.hpp:512:20: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left.accept(this);
                    ^
MAST.hpp:512:20: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:513:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right.accept(this);
                     ^
MAST.hpp:513:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(ForNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:517:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:517:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:517:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:517:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:517:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:517:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:518:7: error: ‘std::list<Node>::iterator’ has no member named ‘accept’
    it.accept(this);
       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp: In member function ‘virtual void VisitorNode::visit(WhileNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:522:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:522:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:522:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:522:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:522:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:522:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:523:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this); 
                   ^
MAST.hpp:523:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
AST.hpp: In member function ‘virtual void VisitorNode::visit(IfNode*)’:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:528:38: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                      ^
MAST.hpp:528:71: error: conversion from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to non-scalar type ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ requested
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                       ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:146:13: error: ‘NodeList* INode::children’ is protected
   NodeList* children;
             ^
In file included from Prueba.cpp:1:0:
MAST.hpp:528:86: error: within this context
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                      ^
MAST.hpp:528:77: error: no match for ‘operator!=’ (operand types are ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ and ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’)
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                             ^
MAST.hpp:528:77: note: candidates are:
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:187:7: note: bool std::_List_iterator<_Tp>::operator!=(const _Self&) const [with _Tp = Node; std::_List_iterator<_Tp>::_Self = std::_List_iterator<Node>]
       operator!=(const _Self& __x) const
       ^
/usr/include/c++/4.8/bits/stl_list.h:187:7: note:   no known conversion for argument 1 from ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ to ‘const _Self& {aka const std::_List_iterator<Node>&}’
In file included from /usr/include/c++/4.8/utility:70:0,
                 from /usr/include/c++/4.8/unordered_map:38,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note: template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)
     operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
     ^
/usr/include/c++/4.8/bits/stl_pair.h:227:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::pair<_T1, _T2>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note: template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)
     operator!=(const reverse_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:303:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)
     operator!=(const reverse_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:353:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::reverse_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note: template<class _IteratorL, class _IteratorR> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_IteratorR>&)
     operator!=(const move_iterator<_IteratorL>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1043:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/stl_algobase.h:67:0,
                 from /usr/include/c++/4.8/bits/char_traits.h:39,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note: template<class _Iterator> bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&)
     operator!=(const move_iterator<_Iterator>& __x,
     ^
/usr/include/c++/4.8/bits/stl_iterator.h:1049:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::move_iterator<_Iterator>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/char_traits.h:40:0,
                 from /usr/include/c++/4.8/string:40,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/postypes.h:221:5: note: template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&, const std::fpos<_StateT>&)
     operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
     ^
/usr/include/c++/4.8/bits/postypes.h:221:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::fpos<_StateT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:138:5: note: template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_T2>&)
     operator!=(const allocator<_T1>&, const allocator<_T2>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:138:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:41:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/allocator.h:143:5: note: template<class _Tp> bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&)
     operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
     ^
/usr/include/c++/4.8/bits/allocator.h:143:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::allocator<_CharT>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2532:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const _CharT*, const std::basic_string<_CharT, _Traits, _Alloc>&)
     operator!=(const _CharT* __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2544:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   mismatched types ‘const _CharT*’ and ‘std::_List_iterator<Node>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/string:52:0,
                 from /usr/include/c++/4.8/stdexcept:39,
                 from /usr/include/c++/4.8/array:38,
                 from /usr/include/c++/4.8/tuple:39,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note: template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const std::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)
     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
     ^
/usr/include/c++/4.8/bits/basic_string.h:2556:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::basic_string<_CharT, _Traits, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/tuple:39:0,
                 from /usr/include/c++/4.8/unordered_map:41,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/array:233:5: note: template<class _Tp, long unsigned int _Nm> bool std::operator!=(const std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)
     operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
     ^
/usr/include/c++/4.8/array:233:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::array<_Tp, _Nm>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:41:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/tuple:833:5: note: template<class ... _TElements, class ... _UElements> constexpr bool std::operator!=(const std::tuple<_Elements ...>&, const std::tuple<_Elements ...>&)
     operator!=(const tuple<_TElements...>& __t,
     ^
/usr/include/c++/4.8/tuple:833:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::tuple<_Elements ...>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1394:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/unordered_map:48:0,
                 from LexList.hpp:11,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note: template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)
     operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
     ^
/usr/include/c++/4.8/bits/unordered_map.h:1406:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/bits/locale_facets.h:48:0,
                 from /usr/include/c++/4.8/bits/basic_ios.h:37,
                 from /usr/include/c++/4.8/ios:44,
                 from /usr/include/c++/4.8/ostream:38,
                 from /usr/include/c++/4.8/iostream:39,
                 from Simbolo.hpp:12,
                 from LexList.hpp:12,
                 from SymbolTable.hpp:9,
                 from MAST.hpp:8,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note: template<class _CharT, class _Traits> bool std::operator!=(const std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT, _Traits>&)
     operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
     ^
/usr/include/c++/4.8/bits/streambuf_iterator.h:210:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::istreambuf_iterator<_CharT, _Traits>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:282:5: note: template<class _Val> bool std::operator!=(const std::_List_iterator<_Tp>&, const std::_List_const_iterator<_Val>&)
     operator!=(const _List_iterator<_Val>& __x,
     ^
/usr/include/c++/4.8/bits/stl_list.h:282:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node*>::iterator {aka std::_List_iterator<Node*>}’ is not derived from ‘const std::_List_const_iterator<_Val>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::list<_Tp, _Alloc>&, const std::list<_Tp, _Alloc>&)
     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_list.h:1638:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::list<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
In file included from /usr/include/c++/4.8/vector:64:0,
                 from AST.hpp:10,
                 from MAST.hpp:10,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note: template<class _Tp, class _Alloc> bool std::operator!=(const std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)
     operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
     ^
/usr/include/c++/4.8/bits/stl_vector.h:1427:5: note:   template argument deduction/substitution failed:
In file included from Prueba.cpp:1:0:
MAST.hpp:528:117: note:   ‘std::list<Node>::iterator {aka std::_List_iterator<Node>}’ is not derived from ‘const std::vector<_Tp, _Alloc>’
   for (list<Node>::iterator it=node->children->children.listas->begin(); it != node->children->children.listas->end(); ++it)
                                                                                                                     ^
MAST.hpp:529:19: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    it->accept(this);
                   ^
MAST.hpp:529:19: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(AssignNode*)’:
MAST.hpp:535:20: error: no matching function for call to ‘AssignNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:535:20: note: candidate is:
MAST.hpp:100:8: note: virtual void AssignNode::accept(Visitor&)
   void accept(Visitor &v){
        ^
MAST.hpp:100:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StmtListNode*)’:
MAST.hpp:540:20: error: no matching function for call to ‘StmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:540:20: note: candidate is:
MAST.hpp:116:8: note: virtual void StmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:116:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(SStmtListNode*)’:
MAST.hpp:545:20: error: no matching function for call to ‘SStmtListNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:545:20: note: candidate is:
MAST.hpp:128:8: note: virtual void SStmtListNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:128:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(ExprNode*)’:
MAST.hpp:550:20: error: no matching function for call to ‘ExprNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:550:20: note: candidate is:
MAST.hpp:140:8: note: virtual void ExprNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:140:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MinusNode*)’:
MAST.hpp:557:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:557:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:558:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:558:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(DiviNode*)’:
MAST.hpp:565:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:565:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:566:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:566:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(MultNode*)’:
MAST.hpp:573:21: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    left->accept(this);
                     ^
MAST.hpp:573:21: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp:574:22: error: no matching function for call to ‘Node::accept(VisitorNode* const)’
    right->accept(this);
                      ^
MAST.hpp:574:22: note: candidate is:
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:47:15: note: virtual void Node::accept(Visitor&)
  virtual void accept(Visitor&)=0;
               ^
AST.hpp:47:15: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from Prueba.cpp:1:0:
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IdentNode*)’:
MAST.hpp:579:21: error: no matching function for call to ‘IdentNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:579:21: note: candidate is:
MAST.hpp:204:8: note: virtual void IdentNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:204:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(IntNode*)’:
MAST.hpp:584:21: error: no matching function for call to ‘IntNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:584:21: note: candidate is:
MAST.hpp:229:8: note: virtual void IntNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:229:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(FloatNode*)’:
MAST.hpp:589:21: error: no matching function for call to ‘FloatNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:589:21: note: candidate is:
MAST.hpp:248:8: note: virtual void FloatNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:248:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(StrNode*)’:
MAST.hpp:594:21: error: no matching function for call to ‘StrNode::accept(VisitorNode* const)’
    node->accept(this);
                     ^
MAST.hpp:594:21: note: candidate is:
MAST.hpp:269:8: note: virtual void StrNode::accept(Visitor&)
   void accept(Visitor &v)
        ^
MAST.hpp:269:8: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
MAST.hpp: In member function ‘virtual void VisitorNode::visit(BoolNode*)’:
MAST.hpp:599:20: error: no matching function for call to ‘BoolNode::accept(VisitorNode* const)’
   node->accept(this);
                    ^
MAST.hpp:599:20: note: candidate is:
MAST.hpp:288:7: note: virtual void BoolNode::accept(Visitor&)
  void accept(Visitor &v)
       ^
MAST.hpp:288:7: note:   no known conversion for argument 1 from ‘VisitorNode* const’ to ‘Visitor&’
In file included from /usr/include/c++/4.8/list:63:0,
                 from MAST.hpp:9,
                 from Prueba.cpp:1:
/usr/include/c++/4.8/bits/stl_list.h: In instantiation of ‘struct std::_List_node<Node>’:
/usr/include/c++/4.8/bits/stl_list.h:146:44:   required from ‘_Tp& std::_List_iterator<_Tp>::operator*() const [with _Tp = Node; std::_List_iterator<_Tp>::reference = Node&]’
MAST.hpp:79:13:   required from here
/usr/include/c++/4.8/bits/stl_list.h:109:11: error: cannot declare field ‘std::_List_node<Node>::_M_data’ to be of abstract type ‘Node’
       _Tp _M_data;
           ^
In file included from MAST.hpp:10:0,
                 from Prueba.cpp:1:
AST.hpp:44:7: note:   since type ‘Node’ has pure virtual functions
 class Node{
       ^
